# High-Performance Cloud: AWS SQS Client

## Intentions

The overall goal is to prototype and develop a high-performance library for working with AWS SQS. The current AWS SDK is feature rich but does appear to allocate heavily during regular use. At scale, in situations where a high volume of messages are processed, this overhead adds up.

The AWS SDK is built on a very layered set of libraries and some autogenerated code. It supports a vast range of target platforms and this limits the scope for rapid change and optimisation.

With the increase in the use of cloud-native services and "async" communication between services, messaging is a prevalent solution to enable distributed scenarios. Even small gains in performance can have a significant impact in high scale environments.

This project launches an experiment to see what enhancements may be possible in a focused library which enables low-level use of the underlying message data.

- Reduce allocations for each message receive request
- Reduce the execution time of each message receive request
- Expose low-level APIs so that raw bytes can be read and fed into downstream systems without the need to allocate higher level constructs. For example, a scenario may be to read and SQS message and immediately store its body into a downstream service such as S3 or ElasticSearch. In that scenario, a high-level class holding complete message properties is often not required. By exposing low-level types, we can enable these forwarding scenarios with limited allocations and basic parsing using Span<T> for example.

## Scenarios

- High-throughput worker services which receive (and process) a very high volume (millions) of messages per day

## Phase One

- Determine repeatable benchmarking and profiling tests
- Profile and benchmark initial scenarios using AWS SDK using those tests to establish a baseline
- Design an initial public API surface (this will change as the project evolves)
- Focus on the architectural structure of the library and components
- Concentrate on designing and building low-level components which support the basic initial scenarios
- Profile and benchmark initial scenarios using this library to compare performance against AWS SDK

### Scope:

Phase one will be limited to a basic SQS reader which supports requests for 1 or more messages from a queue. The focus will be on low-level components which can be used in extremely high-performance scenarios to avoid allocations whenever possible.

For phase one, the library will utilise HttpClient to make requests to the SQS API. There is a small overhead here as AWS request signing requires structured HTTP headers which will force string allocations to construct a valid HttpRequestMessage. A future phase may look a custom dispatcher which supports Sockets and pushing of bytes directly. That could be quite a complex endeavour and may not yield sufficient gains, so that needs to be assessed. For phase one, since we assume this will potentially only target .NET Core 3.0 (see limitations below), we can assume that connection pooling will be in place for us. 

We will not include retry behaviour for phase one and will be limited to basic error handling.

We may not focus on authorisation for phase one and potentially will limit testing to a local containerised version of SQS such as LocalStack, where authorisation is not required. 

## Limitations

During early development, the focus will be on producing a prototype as a proof of concept and to establish a basic set of public APIs. While in development this code may use the latest .NET Core 3.0 and C# 8.0 language features which will limit its consumption. At a later date, we can review if we can target .NET Standard 2.1 and what (if any) earlier targets we can and will include.

## Approach

Initially, this project will be driven to serve specific requirements that I have. Those requirements will influence the project deliverables and aspirations. I want to produce an API surface which is flexible enough for others to take advantage of too. As such, I may use GitHub issues to document proposed APIs and types before development begins. This process should encourage discussion in a similar way to the (corefx) .NET design reviews.

## Future Ideas

- Support emitting metrics, potentially via DiagnosticSource